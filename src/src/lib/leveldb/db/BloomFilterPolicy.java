package lib.leveldb.db;

import java.util.Collection;

import lib.leveldb.DB;
import lib.leveldb.Slice;

class BloomFilterPolicy implements DB.FilterPolicy {

    static final long u32 = 0x0ffffffffL;

    static long BloomHash(Slice key) {
        return Slice.hash( key.data, key.offset, key.length, 0xbc9f1d34 ) & u32;
    }

    final int bitsPerKey;
    final int nProbes; // k_

    BloomFilterPolicy(int bitsPerKey) {

        // A good value for bits_per_key is 10,
        // which yields a filter with ~ 1% false positive rate.

        this.bitsPerKey = bitsPerKey < 0 ? 10 : bitsPerKey;

        // We intentionally round down to reduce probing cost a little bit
        var k = (int) (this.bitsPerKey * 0.69);  // 0.69 =~ ln(2)
        if (k < 1) k = 1;
        if (k > 30) k = 30;
        this.nProbes = k;
    }

    @Override
    public String name() {
        return "leveldb.BuiltinBloomFilter2";
    }

    @Override
    public Slice createFilter(Collection<Slice> keys) {

        // Compute bloom filter size (in both bits and bytes)
        var bits = keys.size() * bitsPerKey;

        // For small n, we can see a very high false positive rate.
        // Fix it by enforcing a minimum bloom filter length.
        if (bits < 64) bits = 64;

        var bytes = (bits + 7) / 8;
        bits = bytes * 8;

        var array = new byte[bytes + 1];
        array[array.length-1] = (byte) nProbes; // Remember # of probes in filter
        for (var key : keys) {
            // Use double-hashing to generate a sequence of hash values.
            // See analysis in [Kirsch,Mitzenmacher 2006].
            var h = BloomHash(key);
            var delta = (h >>> 17) | (h << 15);  // Rotate right 17 bits
            for (var j = 0; j < nProbes; j++) {
                var bitpos = (int)( h % bits );
                array[bitpos/8] |= (1 << (bitpos % 8));
                h += delta;
                h &= u32;
            }
        }
        return new Slice(array);
    }

    @Override
    public boolean keyMayMatch(Slice key, Slice bloomFilter) {
        if (key == null || bloomFilter == null || bloomFilter.length < 2) {
            return false;
        }
        var array = bloomFilter.data;
        var o = bloomFilter.offset;
        var len = bloomFilter.length;
        var bits = (len - 1) * 8;

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        var k = array[o+(len-1)];
        if (k > 30) {
            // Reserved for potentially new encodings for short bloom filters.
            // Consider it a match.
            return true;
        }

        var h = BloomHash(key);
        var delta = (h >>> 17) | (h << 15); // Rotate right 17 bits
        for (var j = 0; j < k; j++) {
            var bitpos = (int)( h % bits );
            if ((array[o+(bitpos/8)] & (1 << (bitpos % 8))) == 0) return false;
            h += delta;
            h &= u32;
        }
        return true;
    }

}